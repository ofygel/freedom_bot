-- Freedom Bot consolidated schema
-- This single file describes the full database structure and seed data
-- required by the application. All statements are idempotent so the
-- script can be reapplied safely on modern PostgreSQL versions.

CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- ---------------------------------------------------------------------------
-- Enum definitions
-- ---------------------------------------------------------------------------
DO $$
DECLARE
  label text;
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role') THEN
    CREATE TYPE user_role AS ENUM ('client', 'courier', 'driver', 'moderator');
  END IF;
  FOREACH label IN ARRAY ARRAY['client', 'courier', 'driver', 'moderator'] LOOP
    EXECUTE format('ALTER TYPE user_role ADD VALUE IF NOT EXISTS %L', label);
  END LOOP;
END
$$;

DO $$
DECLARE
  label text;
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'order_kind') THEN
    CREATE TYPE order_kind AS ENUM ('taxi', 'delivery');
  END IF;
  FOREACH label IN ARRAY ARRAY['taxi', 'delivery'] LOOP
    EXECUTE format('ALTER TYPE order_kind ADD VALUE IF NOT EXISTS %L', label);
  END LOOP;
END
$$;

DO $$
DECLARE
  label text;
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'order_status') THEN
    CREATE TYPE order_status AS ENUM ('open', 'claimed', 'cancelled', 'done');
  END IF;
  FOREACH label IN ARRAY ARRAY['open', 'claimed', 'cancelled', 'done'] LOOP
    EXECUTE format('ALTER TYPE order_status ADD VALUE IF NOT EXISTS %L', label);
  END LOOP;
END
$$;

DO $$
DECLARE
  label text;
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'verification_role') THEN
    CREATE TYPE verification_role AS ENUM ('courier', 'driver');
  END IF;
  FOREACH label IN ARRAY ARRAY['courier', 'driver'] LOOP
    EXECUTE format('ALTER TYPE verification_role ADD VALUE IF NOT EXISTS %L', label);
  END LOOP;
END
$$;

DO $$
DECLARE
  label text;
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'verification_status') THEN
    CREATE TYPE verification_status AS ENUM ('pending', 'active', 'rejected', 'expired');
  END IF;
  FOREACH label IN ARRAY ARRAY['pending', 'active', 'rejected', 'expired'] LOOP
    EXECUTE format('ALTER TYPE verification_status ADD VALUE IF NOT EXISTS %L', label);
  END LOOP;
END
$$;

DO $$
DECLARE
  label text;
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'subscription_status') THEN
    CREATE TYPE subscription_status AS ENUM ('pending', 'active', 'rejected', 'expired');
  END IF;
  FOREACH label IN ARRAY ARRAY['pending', 'active', 'rejected', 'expired'] LOOP
    EXECUTE format('ALTER TYPE subscription_status ADD VALUE IF NOT EXISTS %L', label);
  END LOOP;
END
$$;

DO $$
DECLARE
  label text;
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'payment_status') THEN
    CREATE TYPE payment_status AS ENUM ('pending', 'active', 'rejected', 'expired');
  END IF;
  FOREACH label IN ARRAY ARRAY['pending', 'active', 'rejected', 'expired'] LOOP
    EXECUTE format('ALTER TYPE payment_status ADD VALUE IF NOT EXISTS %L', label);
  END LOOP;
END
$$;

DO $$
DECLARE
  label text;
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'app_city') THEN
    CREATE TYPE app_city AS ENUM ('almaty', 'astana', 'shymkent', 'karaganda');
  END IF;
  FOREACH label IN ARRAY ARRAY['almaty', 'astana', 'shymkent', 'karaganda'] LOOP
    EXECUTE format('ALTER TYPE app_city ADD VALUE IF NOT EXISTS %L', label);
  END LOOP;
END
$$;

-- ---------------------------------------------------------------------------
-- Core tables
-- ---------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS users (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  tg_id bigint NOT NULL UNIQUE,
  username text,
  first_name text,
  last_name text,
  phone text,
  phone_verified boolean NOT NULL DEFAULT false,
  role user_role NOT NULL DEFAULT 'client',
  is_verified boolean NOT NULL DEFAULT false,
  marketing_opt_in boolean NOT NULL DEFAULT false,
  is_blocked boolean NOT NULL DEFAULT false,
  city_selected app_city,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS channels (
  id integer PRIMARY KEY CHECK (id = 1),
  verify_channel_id bigint,
  drivers_channel_id bigint,
  stats_channel_id bigint
);

ALTER TABLE channels ADD COLUMN IF NOT EXISTS stats_channel_id bigint;

ALTER TABLE users
  ADD COLUMN IF NOT EXISTS phone text,
  ADD COLUMN IF NOT EXISTS phone_verified boolean NOT NULL DEFAULT false;

DO $$
BEGIN
  IF EXISTS (
    SELECT 1
    FROM pg_constraint
    WHERE conname = 'users_phone_key'
      AND conrelid = 'users'::regclass
  ) THEN
    EXECUTE 'ALTER TABLE users RENAME CONSTRAINT users_phone_key TO users_phone_unique';
  END IF;
END
$$;

CREATE UNIQUE INDEX IF NOT EXISTS users_phone_unique ON users (phone);

INSERT INTO channels (id)
VALUES (1)
ON CONFLICT (id) DO NOTHING;

CREATE TABLE IF NOT EXISTS verifications (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id bigint NOT NULL REFERENCES users(tg_id) ON DELETE CASCADE,
  role verification_role NOT NULL,
  status verification_status NOT NULL DEFAULT 'pending',
  photos_required integer NOT NULL DEFAULT 0,
  photos_uploaded integer NOT NULL DEFAULT 0,
  expires_at timestamptz,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS verification_photos (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  verification_id bigint NOT NULL REFERENCES verifications(id) ON DELETE CASCADE,
  idx integer NOT NULL,
  file_id text NOT NULL,
  file_unique_id text,
  file_size integer,
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT verification_photos_verification_idx_unique UNIQUE (verification_id, idx)
);

CREATE TABLE IF NOT EXISTS orders (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  short_id text NOT NULL UNIQUE DEFAULT substr(gen_random_uuid()::text, 1, 8),
  kind order_kind NOT NULL,
  status order_status NOT NULL DEFAULT 'open',
  client_id bigint REFERENCES users(tg_id) ON DELETE SET NULL,
  client_phone text,
  recipient_phone text,
  customer_name text,
  customer_username text,
  client_comment text,
  claimed_by bigint REFERENCES users(tg_id) ON DELETE SET NULL,
  claimed_at timestamptz,
  completed_at timestamptz,
  pickup_query text NOT NULL,
  pickup_address text NOT NULL,
  pickup_lat double precision NOT NULL,
  pickup_lon double precision NOT NULL,
  pickup_2gis_url text,
  dropoff_query text NOT NULL,
  dropoff_address text NOT NULL,
  dropoff_lat double precision NOT NULL,
  dropoff_lon double precision NOT NULL,
  dropoff_2gis_url text,
  dropoff_apartment text,
  dropoff_entrance text,
  dropoff_floor text,
  is_private_house boolean,
  price_amount integer NOT NULL,
  price_currency text NOT NULL,
  distance_km double precision NOT NULL,
  channel_message_id bigint,
  city app_city,
  created_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS order_channel_posts (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  order_id bigint NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
  idx integer NOT NULL,
  channel_id bigint NOT NULL,
  message_id bigint NOT NULL,
  thread_id bigint,
  published_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT order_channel_posts_order_idx_unique UNIQUE (order_id, idx),
  CONSTRAINT order_channel_posts_channel_message_unique UNIQUE (channel_id, message_id)
);

CREATE TABLE IF NOT EXISTS subscriptions (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  short_id text NOT NULL UNIQUE DEFAULT substr(gen_random_uuid()::text, 1, 8),
  user_id bigint NOT NULL REFERENCES users(tg_id) ON DELETE CASCADE,
  chat_id bigint NOT NULL,
  plan text NOT NULL,
  tier text,
  status subscription_status NOT NULL DEFAULT 'pending',
  currency text NOT NULL,
  amount integer NOT NULL,
  interval text NOT NULL,
  interval_count integer NOT NULL DEFAULT 1,
  days integer NOT NULL DEFAULT 0,
  next_billing_at timestamptz,
  grace_until timestamptz,
  cancel_at_period_end boolean NOT NULL DEFAULT false,
  cancelled_at timestamptz,
  ended_at timestamptz,
  metadata jsonb NOT NULL DEFAULT '{}'::jsonb,
  last_warning_at timestamptz,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT subscriptions_user_chat_unique UNIQUE (user_id, chat_id)
);

CREATE TABLE IF NOT EXISTS payments (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  short_id text NOT NULL UNIQUE DEFAULT substr(gen_random_uuid()::text, 1, 8),
  subscription_id bigint NOT NULL REFERENCES subscriptions(id) ON DELETE CASCADE,
  user_id bigint NOT NULL REFERENCES users(tg_id) ON DELETE CASCADE,
  amount integer NOT NULL,
  currency text NOT NULL,
  status payment_status NOT NULL DEFAULT 'pending',
  payment_provider text NOT NULL,
  provider_payment_id text,
  provider_customer_id text,
  invoice_url text,
  receipt_url text,
  period_start timestamptz,
  period_end timestamptz,
  paid_at timestamptz,
  days integer,
  file_id text,
  metadata jsonb NOT NULL DEFAULT '{}'::jsonb,
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT payments_provider_payment_unique UNIQUE (provider_payment_id)
);

CREATE TABLE IF NOT EXISTS callback_map (
  idx bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  token text NOT NULL UNIQUE,
  action text NOT NULL,
  chat_id bigint,
  message_id bigint,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  expires_at timestamptz NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS sessions (
  scope text NOT NULL,
  scope_id bigint NOT NULL,
  state jsonb NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (scope, scope_id)
);

CREATE TABLE IF NOT EXISTS support_threads (
  id text PRIMARY KEY,
  short_id text NOT NULL UNIQUE DEFAULT substr(gen_random_uuid()::text, 1, 8),
  user_chat_id bigint NOT NULL,
  user_tg_id bigint REFERENCES users(tg_id),
  user_message_id bigint NOT NULL,
  moderator_chat_id bigint NOT NULL,
  moderator_message_id bigint NOT NULL,
  status text NOT NULL DEFAULT 'open' CHECK (status IN ('open', 'closed')),
  closed_at timestamptz,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

-- ---------------------------------------------------------------------------
-- Indexes
-- ---------------------------------------------------------------------------
CREATE INDEX IF NOT EXISTS idx_users_tg_id ON users(tg_id);
CREATE INDEX IF NOT EXISTS idx_users_city_selected ON users(city_selected);

CREATE INDEX IF NOT EXISTS idx_verifications_user_role_status
  ON verifications(user_id, role, status);
CREATE INDEX IF NOT EXISTS idx_verification_photos_verification_id
  ON verification_photos(verification_id);

CREATE INDEX IF NOT EXISTS idx_orders_status ON orders(status);
CREATE INDEX IF NOT EXISTS idx_orders_claimed_by ON orders(claimed_by);
CREATE INDEX IF NOT EXISTS idx_orders_created_at ON orders(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_orders_city ON orders(city);

CREATE INDEX IF NOT EXISTS idx_order_channel_posts_order_id
  ON order_channel_posts(order_id);
CREATE INDEX IF NOT EXISTS idx_order_channel_posts_channel_message
  ON order_channel_posts(channel_id, message_id);

CREATE INDEX IF NOT EXISTS idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX IF NOT EXISTS idx_subscriptions_user_status ON subscriptions(user_id, status);
CREATE INDEX IF NOT EXISTS idx_subscriptions_chat_id ON subscriptions(chat_id);

CREATE INDEX IF NOT EXISTS idx_payments_subscription_id ON payments(subscription_id);
CREATE INDEX IF NOT EXISTS idx_payments_user_id ON payments(user_id);

CREATE INDEX IF NOT EXISTS idx_callback_map_expires_at ON callback_map(expires_at);

CREATE INDEX IF NOT EXISTS idx_support_threads_status ON support_threads(status);
CREATE INDEX IF NOT EXISTS idx_support_threads_moderator_message
  ON support_threads(moderator_chat_id, moderator_message_id);
-- Enforce explicit lifecycle states for bot users and sessions
ALTER TABLE users
  ADD COLUMN IF NOT EXISTS status text NOT NULL DEFAULT 'guest'
    CHECK (status IN (
      'guest',
      'onboarding',
      'awaiting_phone',
      'active_client',
      'active_executor',
      'trial_expired',
      'suspended',
      'banned'
    )),
  ADD COLUMN IF NOT EXISTS verified_at timestamptz,
  ADD COLUMN IF NOT EXISTS trial_ends_at timestamptz,
  ADD COLUMN IF NOT EXISTS last_menu_role text
    CHECK (last_menu_role IN ('client', 'courier', 'moderator')),
  ADD COLUMN IF NOT EXISTS keyboard_nonce text DEFAULT gen_random_uuid()::text;

CREATE EXTENSION IF NOT EXISTS "pgcrypto";

UPDATE users
SET keyboard_nonce = gen_random_uuid()::text
WHERE keyboard_nonce IS NULL;

CREATE OR REPLACE FUNCTION rotate_keyboard_nonce() RETURNS trigger AS $$
BEGIN
  IF (TG_OP = 'UPDATE') THEN
    IF (OLD.status IS DISTINCT FROM NEW.status)
       OR (OLD.role IS DISTINCT FROM NEW.role) THEN
      NEW.keyboard_nonce := gen_random_uuid()::text;
    END IF;
  END IF;
  RETURN NEW;
END
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_users_rotate_nonce ON users;
CREATE TRIGGER trg_users_rotate_nonce
BEFORE UPDATE OF status, role ON users
FOR EACH ROW EXECUTE FUNCTION rotate_keyboard_nonce();

ALTER TABLE sessions
  ADD COLUMN IF NOT EXISTS flow_state text,
  ADD COLUMN IF NOT EXISTS flow_payload jsonb DEFAULT '{}'::jsonb;
BEGIN;

-- Extend session metadata with flow tracking fields
ALTER TABLE sessions
  ADD COLUMN IF NOT EXISTS flow_state TEXT,
  ADD COLUMN IF NOT EXISTS flow_payload JSONB DEFAULT '{}'::jsonb,
  ADD COLUMN IF NOT EXISTS last_step_at TIMESTAMPTZ,
  ADD COLUMN IF NOT EXISTS nudge_sent_at TIMESTAMPTZ;

-- Journal FSM transitions for diagnostics
CREATE TABLE IF NOT EXISTS fsm_journal (
  id BIGSERIAL PRIMARY KEY,
  scope TEXT NOT NULL,
  scope_id BIGINT NOT NULL,
  from_state TEXT,
  to_state   TEXT,
  step_id    TEXT,
  payload    JSONB,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS fsm_journal_scope_idx
  ON fsm_journal(scope, scope_id, created_at DESC);

-- Idempotency guard for user actions
CREATE TABLE IF NOT EXISTS recent_actions (
  user_id    BIGINT NOT NULL,
  key        TEXT   NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  expires_at TIMESTAMPTZ NOT NULL,
  PRIMARY KEY (user_id, key)
);

CREATE INDEX IF NOT EXISTS recent_actions_expires_idx ON recent_actions(expires_at);

-- Remember last used locations for quick re-ordering
CREATE TABLE IF NOT EXISTS user_recent_locations (
  user_id   BIGINT NOT NULL,
  city      TEXT   NOT NULL,
  kind      TEXT   NOT NULL CHECK (kind IN ('pickup','dropoff')),
  location_id TEXT NOT NULL,
  query     TEXT   NOT NULL,
  address   TEXT   NOT NULL,
  lat       DOUBLE PRECISION NOT NULL,
  lon       DOUBLE PRECISION NOT NULL,
  two_gis_url TEXT,
  last_used_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  PRIMARY KEY (user_id, city, kind, location_id),
  UNIQUE (user_id, city, kind, address)
);

CREATE INDEX IF NOT EXISTS user_recent_locations_last_used_idx
  ON user_recent_locations(user_id, city, kind, last_used_at DESC);

-- Keep only the latest five locations per user/city/kind
CREATE OR REPLACE FUNCTION trim_user_recent_locations() RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM user_recent_locations
  WHERE ctid IN (
    SELECT ctid
    FROM user_recent_locations
    WHERE user_id = NEW.user_id
      AND city = NEW.city
      AND kind = NEW.kind
    ORDER BY last_used_at DESC
    OFFSET 5
  );
  RETURN NEW;
END
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_trim_user_recent_locations ON user_recent_locations;
CREATE TRIGGER trg_trim_user_recent_locations
AFTER INSERT ON user_recent_locations
FOR EACH ROW EXECUTE FUNCTION trim_user_recent_locations();

-- Experiment assignments for lightweight A/B tests
CREATE TABLE IF NOT EXISTS user_experiments (
  user_id    BIGINT NOT NULL,
  experiment TEXT   NOT NULL,
  variant    TEXT   NOT NULL,
  assigned_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  PRIMARY KEY (user_id, experiment)
);

COMMIT;
BEGIN;

-- 1) UI events for CTR and A/B experiments
CREATE TABLE IF NOT EXISTS ui_events (
  id          BIGSERIAL PRIMARY KEY,
  user_id     BIGINT NOT NULL,
  experiment  TEXT,
  variant     TEXT,
  event       TEXT NOT NULL CHECK (event IN ('expose','click')),
  target      TEXT NOT NULL,
  context     JSONB DEFAULT '{}'::jsonb,
  created_at  TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE INDEX IF NOT EXISTS ui_events_user_time_idx ON ui_events(user_id, created_at DESC);
CREATE INDEX IF NOT EXISTS ui_events_target_time_idx ON ui_events(target, created_at DESC);

-- 2) Purge expired idempotency keys
CREATE OR REPLACE FUNCTION purge_recent_actions() RETURNS VOID AS $$
BEGIN
  DELETE FROM recent_actions WHERE expires_at < now();
END; $$ LANGUAGE plpgsql;

COMMIT;
BEGIN;

CREATE OR REPLACE VIEW ui_ctr_daily AS
SELECT
  date_trunc('day', created_at) AS day,
  target,
  count(*) FILTER (WHERE event = 'expose') AS exposures,
  count(*) FILTER (WHERE event = 'click')  AS clicks,
  CASE WHEN count(*) FILTER (WHERE event = 'expose') > 0
       THEN round(100.0 * count(*) FILTER (WHERE event = 'click') / count(*) FILTER (WHERE event = 'expose'), 2)
       ELSE NULL END AS ctr
FROM ui_events
GROUP BY 1,2
ORDER BY 1 DESC, 2;

CREATE OR REPLACE VIEW ui_ctr_overall AS
SELECT
  target,
  count(*) FILTER (WHERE event = 'expose') AS exposures,
  count(*) FILTER (WHERE event = 'click')  AS clicks,
  CASE WHEN count(*) FILTER (WHERE event = 'expose') > 0
       THEN round(100.0 * count(*) FILTER (WHERE event = 'click') / count(*) FILTER (WHERE event = 'expose'), 2)
       ELSE NULL END AS ctr
FROM ui_events
GROUP BY 1
ORDER BY ctr DESC NULLS LAST, exposures DESC;

CREATE OR REPLACE VIEW ui_ctr_by_variant AS
SELECT
  COALESCE(experiment, '-') AS experiment,
  COALESCE(variant, '-')    AS variant,
  target,
  count(*) FILTER (WHERE event = 'expose') AS exposures,
  count(*) FILTER (WHERE event = 'click')  AS clicks,
  CASE WHEN count(*) FILTER (WHERE event = 'expose') > 0
       THEN round(100.0 * count(*) FILTER (WHERE event = 'click') / count(*) FILTER (WHERE event = 'expose'), 2)
       ELSE NULL END AS ctr
FROM ui_events
GROUP BY 1,2,3
ORDER BY 1,2, ctr DESC NULLS LAST, exposures DESC;

COMMIT;
